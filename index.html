<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CamDraw Air</title>
  <style>
    :root { --bg:#0b0f14; --fg:#e8eef6; --muted:#98a2b3; --accent:#4f46e5; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:linear-gradient(180deg,#0b0f14,#111827); color:var(--fg); font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{max-width:1100px; margin:0 auto; padding:16px}
    h1{font-size:20px; margin:8px 0 12px 0}
    .grid{display:grid; grid-template-columns:1fr 320px; gap:14px}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
    .stage{position:relative; background:#000; border-radius:16px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.3); aspect-ratio:16/9; min-height:360px}
    video, canvas{position:absolute; inset:0; width:100%; height:100%}
    video{transform:scaleX(-1); opacity:.45}
    .hud{position:absolute; left:12px; bottom:12px; display:flex; gap:8px; flex-wrap:wrap}
    .chip{background:rgba(15,23,42,.7); color:var(--fg); padding:8px 10px; border-radius:10px; font-size:12px; border:1px solid rgba(148,163,184,.2)}
    .panel{background:rgba(2,6,23,.6); border:1px solid rgba(148,163,184,.2); border-radius:16px; padding:14px; display:flex; flex-direction:column; gap:12px}
    .row{display:flex; align-items:center; gap:10px}
    label{font-size:12px; color:var(--muted); min-width:92px}
    input[type="color"]{width:40px; height:32px; border:0; background:transparent}
    input[type="range"], select{width:100%}
    button{appearance:none; border:1px solid rgba(148,163,184,.25); background:#0b1220; color:var(--fg); padding:9px 12px; border-radius:10px; cursor:pointer}
    button:hover{border-color:rgba(148,163,184,.5)}
    .pill{padding:8px 10px; border-radius:999px; font-size:12px; background:rgba(99,102,241,.1); border:1px solid rgba(99,102,241,.3)}
    .status{font-size:12px; color:var(--muted)}
    .hint{font-size:12px; color:var(--muted)}
    a{color:#a5b4fc}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>CamDraw Air</h1>
    <div class="grid">
      <div class="stage" id="stage">
        <video id="cam" playsinline autoplay muted></video>
        <canvas id="paint"></canvas>
        <canvas id="overlay"></canvas>
        <div class="hud">
          <div class="chip">Pinza para dibujar</div>
          <div class="chip">Palma abierta para limpiar</div>
        </div>
      </div>
      <div class="panel">
        <div class="row"><span class="pill" id="runLabel">Inactivo</span><span class="status" id="fps">0 FPS</span></div>
        <div class="row"><button id="start">Iniciar cámara</button><button id="stop">Detener</button></div>
        <div class="row"><label>Dispositivo</label><select id="device"></select><button id="refresh">Actualizar</button></div>
        <div class="row"><label>Umbral pinza</label><input type="range" id="thresh" min="0.02" max="0.12" step="0.005" value="0.06"></div>
        <div class="row"><label>Modo</label><label><input type="checkbox" id="drawAlways"> Dibujar siempre</label><label><input type="checkbox" id="showDots" checked> Ver puntos</label><button id="compat">Modo compatibilidad</button></div>
        <div class="row"><label>Color</label><input type="color" id="color" value="#00e5ff"></div>
        <div class="row"><label>Grosor</label><input type="range" id="size" min="1" max="30" value="6"></div>
        <div class="row"><label>Suavizado</label><input type="range" id="smooth" min="0" max="0.9" step="0.05" value="0.3"></div>
        <div class="row"><button id="clear">Limpiar lienzo</button><button id="save">Guardar PNG</button></div>
        <div class="status" id="log"></div>
      </div>
    </div>
    </div>
  </div>

  <!-- Carga oficial de MediaPipe Tasks Vision -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14"></script>
  <script>
    const video = document.getElementById('cam')
    const paint = document.getElementById('paint')
    const overlay = document.getElementById('overlay')
    const startBtn = document.getElementById('start')
    const stopBtn = document.getElementById('stop')
    const clearBtn = document.getElementById('clear')
    const saveBtn = document.getElementById('save')
    const colorInp = document.getElementById('color')
    const sizeInp = document.getElementById('size')
    const smoothInp = document.getElementById('smooth')
    const runLabel = document.getElementById('runLabel')
    const fpsEl = document.getElementById('fps')
    const deviceSel = document.getElementById('device')
    const refreshBtn = document.getElementById('refresh')
    const logEl = document.getElementById('log')
    const threshInp = document.getElementById('thresh')
    const drawAlwaysInp = document.getElementById('drawAlways')
    const showDotsInp = document.getElementById('showDots')
    const compatBtn = document.getElementById('compat')

    let stream = null
    let ctxPaint = null
    let ctxOverlay = null
    let width = 0, height = 0
    let lastPt = null
    let drawing = false
    let handLandmarker = null
    let running = false
    let lastTime = performance.now(), frames = 0
    let clearTimer = 0
    // Fallback legacy MediaPipe Hands
    let legacyActive = false
    let legacyLandmarks = null
    let legacyHands = null
    let noDetectMs = 0


    function log(msg){ logEl.textContent = msg }

    function resizeCanvases(){
      const rect = document.getElementById('stage').getBoundingClientRect()
      width = Math.max(320, Math.floor(rect.width))
      height = Math.max(240, Math.floor(rect.height))
      paint.width = width; paint.height = height
      overlay.width = width; overlay.height = height
    }

    function lerp(a,b,t){ return a + (b-a)*t }
    function smoothPoint(prev, next, factor){ if (!prev) return next; return { x: lerp(prev.x,next.x,1 - factor), y: lerp(prev.y,next.y,1 - factor) } }
    function drawCircle(ctx,x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill() }
    function mirrorX(x){ return width - x }
    function pinchDistance(landmarks){ const a = landmarks[4], b = landmarks[8]; const dx = a.x - b.x, dy = a.y - b.y; return Math.hypot(dx,dy) }
    function isPalmOpen(landmarks){ const tipIds = [8,12,16,20]; const palm = landmarks[0].y; return tipIds.every(i => landmarks[i].y < palm - 0.05) }

    async function loadModel(){
      if (handLandmarker) return
      try{
        log('Cargando modelo...')
        const fs = await window.FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm')
        handLandmarker = await window.HandLandmarker.createFromOptions(fs, {
          baseOptions: { modelAssetPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm/hand_landmarker.task' },
          numHands: 1,
          runningMode: 'VIDEO'
        })
        log('Modelo listo')
      }catch(err){
        log('Error al cargar modelo, ' + err.message)
        console.error(err)
      }
    }

    async function enumerateCams(){
      try{
        const devices = await navigator.mediaDevices.enumerateDevices()
        const cams = devices.filter(d => d.kind === 'videoinput')
        deviceSel.innerHTML = ''
        cams.forEach((d,i)=>{ const opt = document.createElement('option'); opt.value = d.deviceId; opt.textContent = d.label || `Cámara ${i+1}`; deviceSel.appendChild(opt) })
        if (!cams.length) log('No se encontraron cámaras')
      }catch(err){ log('No se pudieron listar cámaras, ' + err.message) }
    }

    async function startCamera(){
      try{
        if (stream) return
        await loadModel()
        const deviceId = deviceSel.value || undefined
        const constraints = { video: deviceId ? { deviceId: { exact: deviceId } } : { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' }, audio: false }
        stream = await navigator.mediaDevices.getUserMedia(constraints)
        video.srcObject = stream
        await video.play().catch(()=>{})
        resizeCanvases()
        ctxPaint = paint.getContext('2d')
        ctxPaint.lineCap = 'round'; ctxPaint.lineJoin = 'round'
        ctxOverlay = overlay.getContext('2d')
        running = true
        runLabel.textContent = 'Activo'
        log('Cámara iniciada')
        loop()
      }catch(err){
        log('Error al iniciar cámara, ' + err.message)
        console.error(err)
        alert('No se pudo iniciar la cámara. Revisa permisos del sitio y prueba en una ventana privada sin extensiones')
      }
    }

    async function stopCamera(){
      running = false
      runLabel.textContent = 'Inactivo'
      if (stream){ stream.getTracks().forEach(t => t.stop()) }
      stream = null
      lastPt = null
      drawing = false
      if (ctxOverlay) ctxOverlay.clearRect(0,0,overlay.width,overlay.height)
    }

    async function loop(){
      if (!running) return
      const now = performance.now()
      frames++
      if (now - lastTime > 1000){ fpsEl.textContent = frames + ' FPS'; lastTime = now; frames = 0 }

      const vw = video.videoWidth || width
      const vh = video.videoHeight || height
      if (vw && vh){ const stageRect = document.getElementById('stage').getBoundingClientRect(); width = stageRect.width|0; height = stageRect.height|0; paint.width = width; paint.height = height; overlay.width = width; overlay.height = height }

      let results = handLandmarker ? handLandmarker.detectForVideo(video, now) : null
      if (!results || !results.landmarks || !results.landmarks.length){ noDetectMs += 16 } else { noDetectMs = 0 }
      if (!legacyActive && noDetectMs > 1500){ initLegacyHands() }
      if (legacyActive && legacyLandmarks){ results = { landmarks: [ legacyLandmarks.map(p => ({x:p.x, y:p.y})) ] } }
      ctxOverlay.clearRect(0,0,width,height)

      if (results && results.landmarks && results.landmarks.length){
        const lm = results.landmarks[0]
        const pts = lm.map(p => ({ x: mirrorX(p.x * width), y: p.y * height }))

        // Visualización
        if (showDotsInp.checked){
          ctxOverlay.strokeStyle = 'rgba(164, 202, 255, .6)'; ctxOverlay.lineWidth = 2
          ctxOverlay.beginPath(); [0,5,9,13,17,0].forEach((idx,i)=>{ const pt = pts[idx]; if (i===0) ctxOverlay.moveTo(pt.x, pt.y); else ctxOverlay.lineTo(pt.x, pt.y) }); ctxOverlay.stroke()
          ctxOverlay.fillStyle = 'rgba(99,102,241,.9)'; drawCircle(ctxOverlay, pts[8].x, pts[8].y, 5)
        }

        const pinch = pinchDistance(lm)
        const threshold = parseFloat(threshInp.value)
        const pinchOn = drawAlwaysInp.checked || (pinch < threshold)
        const palmOpen = isPalmOpen(lm)

        log(`Mano, sí, Pinza ${pinch.toFixed(3)} ${pinchOn ? 'ON' : 'OFF'}`)

        if (palmOpen){ if (!clearTimer) clearTimer = now; if (now - clearTimer > 1000){ ctxPaint.clearRect(0,0,width,height); clearTimer = 0 } } else { clearTimer = 0 }
        const rawPt = { x: pts[8].x, y: pts[8].y }
        const sm = parseFloat(smoothInp.value)
        const cur = smoothPoint(lastPt, rawPt, sm)
        const size = parseInt(sizeInp.value,10)
        ctxPaint.strokeStyle = colorInp.value; ctxPaint.lineWidth = size
        if (pinchOn){ if (!drawing || !lastPt){ ctxPaint.beginPath(); ctxPaint.moveTo(cur.x, cur.y) } else { ctxPaint.lineTo(cur.x, cur.y); ctxPaint.stroke() } drawing = true; lastPt = cur }
        else { drawing = false; lastPt = cur }
      } else { drawing = false; lastPt = null; log('Mano, no detectada') }

      requestAnimationFrame(loop)
    }

    startBtn.addEventListener('click', startCamera)
    stopBtn.addEventListener('click', stopCamera)
    clearBtn.addEventListener('click', ()=> ctxPaint && ctxPaint.clearRect(0,0,paint.width,paint.height))
    saveBtn.addEventListener('click', ()=>{ const out = document.createElement('canvas'); out.width = width; out.height = height; const octx = out.getContext('2d'); octx.drawImage(paint,0,0); const link = document.createElement('a'); link.download = `CamDraw-${Date.now()}.png`; link.href = out.toDataURL('image/png'); link.click() })
    refreshBtn.addEventListener('click', enumerateCams)
    compatBtn.addEventListener('click', initLegacyHands)

    if (!location.protocol.startsWith('https')){ log('Abre esta página con HTTPS') }
    enumerateCams()
    window.addEventListener('resize', resizeCanvases)

    async function loadScript(src){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.body.appendChild(s) }) }
    async function initLegacyHands(){
      if (legacyHands) { legacyActive = true; log('Compat, activo'); return }
      try{
        log('Cargando modo compatibilidad...')
        await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js')
        await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js')
        legacyHands = new window.Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` })
        legacyHands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.3, minTrackingConfidence:0.3 })
        legacyHands.onResults(r=>{ if (r.multiHandLandmarks && r.multiHandLandmarks.length){ legacyLandmarks = r.multiHandLandmarks[0]; } else { legacyLandmarks = null } })
        async function pump(){ if (!legacyActive) return; if (video.readyState >= 2){ await legacyHands.send({image: video}) } requestAnimationFrame(pump) }
        legacyActive = true
        pump()
        log('Compat, activo')
      }catch(e){ log('Error compat, ' + e.message) }
    }
  </script>
</body>
</html>
